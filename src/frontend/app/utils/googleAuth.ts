import * as AuthSession from 'expo-auth-session';
import { makeRedirectUri } from 'expo-auth-session';
import Constants from 'expo-constants';
import { Platform } from 'react-native';

export type GoogleAuthResult = {
  idToken?: string;
  accessToken?: string;
  expiresIn?: number;
  tokenType?: string;
  scope?: string;
  raw?: any;
};

export async function signInWithGoogle(): Promise<GoogleAuthResult | null> {
  // Prefer iOS native client + Code PKCE to comply with Google policy
  const iosClientId = process.env.EXPO_PUBLIC_GOOGLE_CLIENT_ID_IOS || '';
  const webClientId = process.env.EXPO_PUBLIC_GOOGLE_CLIENT_ID || '';
  const appOwnership = (Constants as any).appOwnership as ('expo' | 'guest' | 'standalone' | undefined);
  // Prefer explicit proxy URL only if the ENV var is set (do not use defaults)
  const AUTH_PROXY_ENV = process.env.EXPO_PUBLIC_AUTH_PROXY_URL || '';
  const explicitProxy = AUTH_PROXY_ENV.match(/auth\.expo\.(dev|io)/) ? AUTH_PROXY_ENV : '';
  // Candidate generated by AuthSession (may fallback to custom scheme in Dev Client)
  const generatedProxy = (makeRedirectUri as any)({ useProxy: true, preferLocalhost: false, isTripleSlashed: true });
  const hasGeneratedProxy = /auth\.expo\.(dev|io)/.test(generatedProxy);
  // Final proxy URL to use for web flow
  const proxyRedirect = explicitProxy || (hasGeneratedProxy ? generatedProxy : '');
  const hasExpoProxy = !!proxyRedirect;
  // In Expo Go/Dev Client, if proxy available, force web/proxy flow.
  // Use iOS native only when iOS, native client id present, and no proxy specified.
  const usingIOSClient = !!iosClientId && Platform.OS === 'ios' && !hasExpoProxy && appOwnership !== 'expo';
  const clientId = usingIOSClient ? iosClientId : webClientId;
  if (!clientId) {
    throw new Error('Missing Google OAuth client id. Set EXPO_PUBLIC_GOOGLE_CLIENT_ID_IOS or EXPO_PUBLIC_GOOGLE_CLIENT_ID');
  }

  // Build redirect URI
  // For iOS native client, Google expects an exact value:
  //   com.googleusercontent.apps.<client_id-without-.apps.googleusercontent.com>:/oauthredirect
  const redirectUri = usingIOSClient
    ? ((): string => {
        const iosIdForScheme = clientId.replace('.apps.googleusercontent.com', '');
        return `com.googleusercontent.apps.${iosIdForScheme}:/oauthredirect`;
      })()
    : (proxyRedirect || generatedProxy);

  // Debug logging to verify chosen flow
  try {
    console.log('🔐 GoogleAuth config', { usingIOSClient, clientId, redirectUri, appOwnership, hasExpoProxy, explicitProxy, generatedProxy });
  } catch {}

  const discovery = {
    authorizationEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',
    tokenEndpoint: 'https://oauth2.googleapis.com/token',
    revocationEndpoint: 'https://oauth2.googleapis.com/revoke',
  };

  const request = new AuthSession.AuthRequest({
    clientId,
    redirectUri,
    responseType: usingIOSClient ? AuthSession.ResponseType.Code : AuthSession.ResponseType.IdToken,
    scopes: ['openid', 'email', 'profile'],
    prompt: AuthSession.Prompt.SelectAccount,
    // Native iOS: Code + PKCE; Web proxy: id_token without PKCE
    usePKCE: usingIOSClient,
  });

  if (usingIOSClient) {
    // Authorization Code + PKCE (no client secret)
    await (request.makeAuthUrlAsync as any)(discovery, { useProxy: false });
    const auth = await (request.promptAsync as any)(discovery, { useProxy: false });
    if (auth.type !== 'success') {
      // Fallback to web/proxy flow if available
      if (webClientId) {
        try {
          const proxyRedirect = (makeRedirectUri as any)({ useProxy: true, preferLocalhost: false, isTripleSlashed: true });
          const fallback = new AuthSession.AuthRequest({
            clientId: webClientId,
            redirectUri: proxyRedirect,
            responseType: AuthSession.ResponseType.IdToken,
            scopes: ['openid', 'email', 'profile'],
            prompt: AuthSession.Prompt.SelectAccount,
            usePKCE: false,
          });
          const nonce = `${Date.now().toString(36)}.${Math.random().toString(36).slice(2, 10)}`;
          (fallback as any).extraParams = { ...(fallback as any).extraParams, nonce };
          await (fallback.makeAuthUrlAsync as any)(discovery, { useProxy: true });
          const res = await (fallback.promptAsync as any)(discovery, { useProxy: true });
          if (res.type === 'success') {
            const idToken = (res as any).params?.id_token;
            return { idToken, raw: res };
          }
        } catch {}
      }
      return null;
    }
    const code = (auth as any).params?.code as string | undefined;
    if (!code) return null;
    const token = await AuthSession.exchangeCodeAsync(
      {
        code,
        clientId,
        redirectUri,
        // PKCE
        extraParams: { code_verifier: request.codeVerifier || '' },
      },
      discovery
    );
    const idToken = (token as any).idToken || (token as any).id_token;
    return { idToken, accessToken: (token as any).accessToken || (token as any).access_token, raw: token } as any;
  } else {
    // Web client via Expo proxy (id_token)
    // Google requires a "nonce" when using response_type=id_token
    const nonce = `${Date.now().toString(36)}.${Math.random().toString(36).slice(2, 10)}`;
    // ensure nonce is included in the authorization request
    // (AuthSession doesn't add it automatically for IdToken flow when configured manually)
    (request as any).extraParams = { ...(request as any).extraParams, nonce };
    try {
      await (request.makeAuthUrlAsync as any)(discovery, { useProxy: true });
      const result = await (request.promptAsync as any)(discovery, { useProxy: true });
      if (result.type === 'success') {
        const idToken = (result as any).params?.id_token;
        return { idToken, raw: result };
      }
      // Fall through to native fallback
    } catch {}

    // Fallback: try iOS native flow if available (helps when TLS blocks auth.expo.dev)
    if (Platform.OS === 'ios' && iosClientId) {
      const nativeRedirect = (() => {
        const iosIdForScheme = iosClientId.replace('.apps.googleusercontent.com', '');
        return `com.googleusercontent.apps.${iosIdForScheme}:/oauthredirect`;
      })();
      const nativeReq = new AuthSession.AuthRequest({
        clientId: iosClientId,
        redirectUri: nativeRedirect,
        responseType: AuthSession.ResponseType.Code,
        scopes: ['openid', 'email', 'profile'],
        prompt: AuthSession.Prompt.SelectAccount,
        usePKCE: true,
      });
      try {
      await (nativeReq.makeAuthUrlAsync as any)(discovery, { useProxy: false });
      const auth = await (nativeReq.promptAsync as any)(discovery, { useProxy: false });
        if (auth.type !== 'success') return null;
        const code = (auth as any).params?.code as string | undefined;
        if (!code) return null;
        const token = await AuthSession.exchangeCodeAsync(
          {
            code,
            clientId: iosClientId,
            redirectUri: nativeRedirect,
            extraParams: { code_verifier: nativeReq.codeVerifier || '' },
          },
          discovery
        );
        return { idToken: (token as any).id_token, accessToken: token.accessToken, raw: token } as any;
      } catch {}
    }
    return null;
  }
}
