import { Actor, HttpAgent, Identity } from '@dfinity/agent';
import { DEBUG_CONFIG, debugLog } from '../utils/debugConfig';
import { Principal } from '@dfinity/principal';
import { CustomPrincipal } from '../utils/principal';
import { CANISTER_ID_UNIFIED } from '../constants';

// „É°„Ç§„É≥„Éç„ÉÉ„ÉàÁµ±ÂêàCanister IDË®≠ÂÆö
const UNIFIED_CANISTER_ID = CANISTER_ID_UNIFIED;

// ======================================
// V2 Types (Êñ∞„Åó„ÅÑÊ§úÁ¥¢ÂØæÂøúÁâà)
// ======================================

export type SceneKind = 
  | { Nature: null }
  | { Building: null } 
  | { Store: null }
  | { Facility: null }
  | { Other: null };


export type CountryCode = string; // ÂõΩÂêçÔºà‰æã: "Japan"Ôºâ
export type RegionCode = string;  // Âú∞ÂüüÂêçÔºà‰æã: "Tokyo, Japan"Ôºâ
export type GeoHash = string;

export type ChunkUploadState = 
  | { Incomplete: null }
  | { Complete: null }
  | { Failed: null };

export interface CreatePhotoRequest {
  // ‰ΩçÁΩÆÊÉÖÂ†±
  latitude: number;
  longitude: number;
  azimuth: number | null;
  
  // Ë°®Á§∫Áî®„É°„Çø„Éá„Éº„Çø
  title: string;
  description: string;
  difficulty: 'EASY' | 'NORMAL' | 'HARD' | 'EXTREME';
  hint: string;
  
  // Ê§úÁ¥¢Â±ûÊÄß
  country: CountryCode; // Ê≠£Ë¶èÂåñ„Åï„Çå„ÅüÂõΩÂêç
  region: RegionCode;   // ÂÆåÂÖ®„Å™Âú∞ÂüüÂêçÔºà"City, Country"ÂΩ¢ÂºèÔºâ
  sceneKind: SceneKind;
  tags: string[];
  
  // „ÉÅ„É£„É≥„ÇØÊÉÖÂ†±
  expectedChunks: bigint;
  totalSize: bigint;
}

export interface PhotoMetaV2 {
  // Âü∫Êú¨ÊÉÖÂ†±
  id: bigint;
  owner: Principal;
  uploadTime: bigint; // IDL.Int -> bigint (ÊôÇÈñì„ÅØÂ§ß„Åç„Å™Êï∞ÂÄ§„Å´„Å™„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅ)
  
  // ‰ΩçÁΩÆÊÉÖÂ†±
  latitude: number;
  longitude: number;
  azimuth: number[] | []; // IDL OptionalÂûã„ÅØÈÖçÂàóÂΩ¢Âºè
  geoHash: GeoHash;
  
  // Ë°®Á§∫Áî®„É°„Çø„Éá„Éº„Çø
  title: string;
  description: string;
  difficulty: { EASY: null } | { NORMAL: null } | { HARD: null } | { EXTREME: null };
  hint: string;
  
  // Ê§úÁ¥¢Â±ûÊÄß
  country: CountryCode; // Ê≠£Ë¶èÂåñ„Åï„Çå„ÅüÂõΩÂêç
  region: RegionCode;   // ÂÆåÂÖ®„Å™Âú∞ÂüüÂêçÔºà"City, Country"ÂΩ¢ÂºèÔºâ
  sceneKind: SceneKind;
  tags: string[];
  
  // ÁîªÂÉè„ÉÅ„É£„É≥„ÇØÊÉÖÂ†±
  chunkCount: bigint;
  totalSize: bigint;
  uploadState: ChunkUploadState;
  
  // ÂÜÖÈÉ®ÁÆ°ÁêÜ
  status: { Active: null } | { Banned: null } | { Deleted: null };
  timesUsed: bigint;
  lastUsedTime: bigint[] | []; // IDL OptionalÂûã„ÅØÈÖçÂàóÂΩ¢Âºè (IDL.Int -> bigint)
  
  // Áµ±Ë®àÊÉÖÂ†±„ÅØÂà•ÈÄîAPI„ÅßÂèñÂæó
}

export interface PhotoStatsDetailsV2 {
  totalScore: bigint;      // Á¥ØË®àÂæóÁÇπ
  averageScore: number;    // Âπ≥ÂùáÂæóÁÇπ
  bestScore: bigint;       // ÊúÄÈ´òÂæóÁÇπ
  worstScore: bigint;      // ÊúÄ‰ΩéÂæóÁÇπ
  playCount: bigint;       // „Éó„É¨„Ç§ÂõûÊï∞
}

export interface SearchFilter {
  country?: CountryCode;
  region?: RegionCode;
  sceneKind?: SceneKind;
  tags?: string[];
  nearLocation?: {
    latitude: number;
    longitude: number;
    radiusKm: number;
  };
  owner?: Principal;
  difficulty?: { EASY: null } | { NORMAL: null } | { HARD: null } | { EXTREME: null };
  status?: { Active: null } | { Banned: null } | { Deleted: null };
}

export interface SearchResult {
  photos: PhotoMetaV2[];
  totalCount: bigint;
  cursor: bigint | null;
  hasMore: boolean;
}

export interface OverallPhotoStatsV2 {
  totalPhotos: bigint;
  activePhotos: bigint;
  totalSize: bigint;
  photosByCountry: Array<[CountryCode, bigint]>;
  photosByRegion: Array<[RegionCode, bigint]>;
  photosBySceneKind: Array<[SceneKind, bigint]>;
  popularTags: Array<[string, bigint]>;
}

// IDL„Éï„Ç°„ÇØ„Éà„É™„ÉºÔºàV2ÁâàÔºâ
const idlFactory = ({ IDL }: any) => {
  const SceneKind = IDL.Variant({
    'Nature': IDL.Null,
    'Building': IDL.Null,
    'Store': IDL.Null,
    'Facility': IDL.Null,
    'Other': IDL.Null,
  });

  const CountryCode = IDL.Text;
  const RegionCode = IDL.Text;
  const GeoHash = IDL.Text;

  const ChunkUploadState = IDL.Variant({
    'Incomplete': IDL.Null,
    'Complete': IDL.Null,
    'Failed': IDL.Null,
  });

  const CreatePhotoRequest = IDL.Record({
    latitude: IDL.Float64,
    longitude: IDL.Float64,
    azimuth: IDL.Opt(IDL.Float64),
    title: IDL.Text,
    description: IDL.Text,
    difficulty: IDL.Variant({
      'EASY': IDL.Null,
      'NORMAL': IDL.Null,
      'HARD': IDL.Null,
      'EXTREME': IDL.Null,
    }),
    hint: IDL.Text,
    country: CountryCode,
    region: RegionCode,
    sceneKind: SceneKind,
    tags: IDL.Vec(IDL.Text),
    expectedChunks: IDL.Nat,
    totalSize: IDL.Nat,
  });

  const PhotoMetaV2 = IDL.Record({
    id: IDL.Nat,
    owner: IDL.Principal,
    uploadTime: IDL.Int,
    latitude: IDL.Float64,
    longitude: IDL.Float64,
    azimuth: IDL.Opt(IDL.Float64),
    geoHash: GeoHash,
    title: IDL.Text,
    description: IDL.Text,
    difficulty: IDL.Variant({
      'EASY': IDL.Null,
      'NORMAL': IDL.Null,
      'HARD': IDL.Null,
      'EXTREME': IDL.Null,
    }),
    hint: IDL.Text,
    country: CountryCode,
    region: RegionCode,
    sceneKind: SceneKind,
    tags: IDL.Vec(IDL.Text),
    chunkCount: IDL.Nat,
    totalSize: IDL.Nat,
    uploadState: ChunkUploadState,
    status: IDL.Variant({
      'Active': IDL.Null,
      'Banned': IDL.Null,
      'Deleted': IDL.Null,
    }),
    timesUsed: IDL.Nat,
    lastUsedTime: IDL.Opt(IDL.Int),
  });

  const PhotoStatsDetails = IDL.Record({
    totalScore: IDL.Nat,
    averageScore: IDL.Float64,
    bestScore: IDL.Nat,
    worstScore: IDL.Nat,
    playCount: IDL.Nat,
  });

  const SearchFilter = IDL.Record({
    country: IDL.Opt(CountryCode),
    region: IDL.Opt(RegionCode),
    sceneKind: IDL.Opt(SceneKind),
    tags: IDL.Opt(IDL.Vec(IDL.Text)),
    nearLocation: IDL.Opt(IDL.Record({
      latitude: IDL.Float64,
      longitude: IDL.Float64,
      radiusKm: IDL.Float64,
    })),
    owner: IDL.Opt(IDL.Principal),
    difficulty: IDL.Opt(IDL.Variant({
      'EASY': IDL.Null,
      'NORMAL': IDL.Null,
      'HARD': IDL.Null,
      'EXTREME': IDL.Null,
    })),
    status: IDL.Opt(IDL.Variant({
      'Active': IDL.Null,
      'Banned': IDL.Null,
      'Deleted': IDL.Null,
    })),
  });

  const SearchResult = IDL.Record({
    photos: IDL.Vec(PhotoMetaV2),
    totalCount: IDL.Nat,
    cursor: IDL.Opt(IDL.Nat),
    hasMore: IDL.Bool,
  });

  const OverallPhotoStats = IDL.Record({
    totalPhotos: IDL.Nat,
    activePhotos: IDL.Nat,
    totalSize: IDL.Nat,
    photosByCountry: IDL.Vec(IDL.Tuple(CountryCode, IDL.Nat)),
    photosByRegion: IDL.Vec(IDL.Tuple(RegionCode, IDL.Nat)),
    photosBySceneKind: IDL.Vec(IDL.Tuple(SceneKind, IDL.Nat)),
    popularTags: IDL.Vec(IDL.Tuple(IDL.Text, IDL.Nat)),
  });


  const Result = IDL.Variant({
    'ok': IDL.Nat,
    'err': IDL.Text,
  });

  const ResultEmpty = IDL.Variant({
    'ok': IDL.Null,
    'err': IDL.Text,
  });

  return IDL.Service({
    createPhotoV2: IDL.Func([CreatePhotoRequest], [Result], []),
    uploadPhotoChunkV2: IDL.Func([IDL.Nat, IDL.Nat, IDL.Vec(IDL.Nat8)], [ResultEmpty], []),
    finalizePhotoUploadV2: IDL.Func([IDL.Nat], [ResultEmpty], []),
    searchPhotosV2: IDL.Func([SearchFilter, IDL.Opt(IDL.Nat), IDL.Nat], [SearchResult], ['query']),
    getPhotoMetadataV2: IDL.Func([IDL.Nat], [IDL.Opt(PhotoMetaV2)], ['query']),
    getPhotoChunkV2: IDL.Func([IDL.Nat, IDL.Nat], [IDL.Opt(IDL.Vec(IDL.Nat8))], ['query']),
    getPhotoCompleteDataV2: IDL.Func([IDL.Nat], [IDL.Opt(IDL.Vec(IDL.Nat8))], ['query']),
    getPhotoStatsV2: IDL.Func([], [OverallPhotoStats], ['query']),
    getPhotoStatsDetailsV2: IDL.Func([IDL.Nat], [IDL.Opt(PhotoStatsDetails)], ['query']),
    getUserPhotosV2: IDL.Func([IDL.Opt(IDL.Nat), IDL.Nat], [SearchResult], ['query']),
    deletePhotoV2: IDL.Func([IDL.Nat], [ResultEmpty], []),
  });
};

class PhotoServiceV2 {
  private agent: HttpAgent | null = null;
  private actor: any = null;
  private identity: Identity | null = null;
  private photoCache: Map<string, PhotoMetaV2> = new Map();
  private chunkCache: Map<string, Uint8Array> = new Map();
  private dataUrlCache: Map<string, string> = new Map();
  private statsCache: Map<string, PhotoStatsDetailsV2> = new Map();
  private cacheTimeout = 5 * 60 * 1000; // 5ÂàÜ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•

  async init(identity: Identity) {
    try {
      if (!identity) {
        throw new Error('No identity provided');
      }

      // Reuse existing actor if identity hasn't changed
      if (this.identity === identity && this.actor) {
        return;
      }

      this.identity = identity;
      const host = process.env.EXPO_PUBLIC_IC_HOST || 'https://ic0.app';
      const canisterId = UNIFIED_CANISTER_ID;
      
      debugLog('API_CALLS', 'üñºÔ∏è Initializing photo service V2:', { host, canisterId });
      
      // Dev mode„ÅÆÁ¢∫Ë™çÔºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
      const isDevMode = identity.constructor.name === 'Ed25519KeyIdentity';
      
      this.agent = new HttpAgent({
        identity,
        host: host,
        verifyQuerySignatures: true, // ÁΩ≤ÂêçÊ§úË®º„ÇíÊúâÂäπÂåñÔºàÊ≠£„Åó„ÅÑ„Éó„É™„É≥„Ç∑„Éë„É´„Çí‰ΩøÁî®Ôºâ
        // API v3„ÇíÊúâÂäπÂåñ„Åó„Å¶È´òÈÄüÂåñ
        useQueryNonces: true,
        retryTimes: 3,
        // Fetch options for timeout and performance
        fetchOptions: {
          reactNative: {
            // React NativeÁî®„ÅÆÊúÄÈÅ©Âåñ
            __nativeResponseType: 'base64',
          },
        },
      });

      // Dev mode„ÅÆÂ†¥Âêà„ÄÅËøΩÂä†„ÅÆË®≠ÂÆö
      if (isDevMode) {
        debugLog('API_CALLS', 'üñºÔ∏è Dev mode detected - certificate verification will be handled by early patches');
      }

      this.actor = Actor.createActor(idlFactory, {
        agent: this.agent,
        canisterId: canisterId,
      });
      
      debugLog('API_CALLS', 'üñºÔ∏è Photo service V2 initialized successfully');
    } catch (error) {
      console.error('‚ùå Failed to initialize photo service V2:', error);
      throw error;
    }
  }

  /**
   * ÂÜôÁúü„ÅÆ‰ΩúÊàêÔºà„ÉÅ„É£„É≥„ÇØ„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÈñãÂßãÔºâ
   */
  async createPhoto(request: CreatePhotoRequest, identity?: Identity): Promise<{ ok?: bigint; err?: string }> {
    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      // IDL variantÂûã„Å®OptionalÂûãÁî®„ÅÆÂ§âÊèõ„ÇíË°å„ÅÜ
      const idlRequest = {
        ...request,
        azimuth: request.azimuth !== null ? [request.azimuth] : [], // null ‚Üí [] „Å´Â§âÊèõ
        difficulty: difficultyFromString(request.difficulty), // ÊñáÂ≠óÂàó ‚Üí variantÂûã„Å´Â§âÊèõ
      };
      
      debugLog('API_CALLS', 'üñºÔ∏è Creating photo with request:', request);
      const result = await this.actor.createPhotoV2(idlRequest);
      debugLog('API_CALLS', 'üñºÔ∏è Photo created:', result);
      return result;
    } catch (error) {
      console.error('‚ùå Create photo error:', error);
      return { err: error instanceof Error ? error.message : 'Create failed' };
    }
  }

  /**
   * „ÉÅ„É£„É≥„ÇØ„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
   */
  async uploadChunk(photoId: bigint, chunkIndex: bigint, data: Uint8Array, identity?: Identity): Promise<{ ok?: null; err?: string }> {
    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      console.log(`üñºÔ∏è Uploading chunk ${chunkIndex} for photo ${photoId}, size: ${data.length}`);
      const result = await this.actor.uploadPhotoChunkV2(photoId, chunkIndex, data);
      console.log('üñºÔ∏è Chunk uploaded:', result);
      return result;
    } catch (error) {
      console.error('‚ùå Upload chunk error:', error);
      return { err: error instanceof Error ? error.message : 'Upload failed' };
    }
  }

  /**
   * „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÇíÂÆå‰∫Ü
   */
  async finalizeUpload(photoId: bigint, identity?: Identity): Promise<{ ok?: null; err?: string }> {
    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      console.log(`üñºÔ∏è Finalizing upload for photo ${photoId}`);
      const result = await this.actor.finalizePhotoUploadV2(photoId);
      console.log('üñºÔ∏è Upload finalized:', result);
      return result;
    } catch (error) {
      console.error('‚ùå Finalize upload error:', error);
      return { err: error instanceof Error ? error.message : 'Finalize failed' };
    }
  }

  /**
   * ÂÜôÁúü„ÇíÊ§úÁ¥¢
   */
  async searchPhotos(filter: SearchFilter, cursor?: bigint, limit: number = 20, identity?: Identity): Promise<SearchResult> {
    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      console.log('üîç Searching photos with filter:', filter);
      
      // Convert TypeScript optional fields to IDL Optional format
      const idlFilter = {
        country: filter.country ? [filter.country] : [],
        region: filter.region ? [filter.region] : [],
        sceneKind: filter.sceneKind ? [filter.sceneKind] : [],
        tags: filter.tags ? [filter.tags] : [],
        nearLocation: filter.nearLocation ? [filter.nearLocation] : [],
        owner: filter.owner ? [filter.owner] : [],
        difficulty: filter.difficulty ? [filter.difficulty] : [],
        status: filter.status ? [filter.status] : [],
      };
      
      const result = await this.actor.searchPhotosV2(idlFilter, cursor ? [cursor] : [], BigInt(limit));
      console.log(`üîç Found ${result.photos.length} photos`);
      return result;
    } catch (error) {
      console.error('‚ùå Search photos error:', error);
      return {
        photos: [],
        totalCount: BigInt(0),
        cursor: null,
        hasMore: false,
      };
    }
  }

  /**
   * ÈÄ±ÈñìÂÜôÁúü„ÇíÂèñÂæóÔºàÈÅéÂéª7Êó•ÈñìÔºâ
   */
  async getWeeklyPhotos(regionFilter?: string, limit: number = 100, identity?: Identity): Promise<SearchResult> {
    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      console.log('üìÖ Getting weekly photos with region filter:', regionFilter);
      
      const result = await this.actor.getWeeklyPhotos(
        regionFilter ? [regionFilter] : [],
        BigInt(limit)
      );
      
      console.log(`üìÖ Found ${result.photos.length} photos from this week`);
      return result;
    } catch (error) {
      console.error('‚ùå Get weekly photos error:', error);
      return {
        photos: [],
        totalCount: BigInt(0),
        cursor: null,
        hasMore: false,
      };
    }
  }

  /**
   * ÂÜôÁúü„É°„Çø„Éá„Éº„Çø„ÇíÂèñÂæóÔºà„Ç≠„É£„ÉÉ„Ç∑„É•‰ªò„ÅçÔºâ
   */
  async getPhotoMetadata(photoId: bigint, identity?: Identity): Promise<PhotoMetaV2 | null> {
    // „Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    const cacheKey = `photo_${photoId}`;
    const cached = this.photoCache.get(cacheKey);
    if (cached) {
      console.log('üöÄ Photo metadata cache hit:', photoId);
      return cached;
    }

    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      debugLog('API_CALLS', 'üì• Fetching photo metadata:', photoId);
      const startTime = Date.now();
      
      const result = await this.actor.getPhotoMetadataV2(photoId);
      
      const fetchTime = Date.now() - startTime;
      debugLog('API_CALLS', `üìä Photo metadata fetch time: ${fetchTime}ms`);
      
      if (result.length > 0) {
        const metadata = result[0];
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠ò
        this.photoCache.set(cacheKey, metadata);
        setTimeout(() => this.photoCache.delete(cacheKey), this.cacheTimeout);
        
        return metadata;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Get photo metadata error:', error);
      return null;
    }
  }

  /**
   * ÂÜôÁúü„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíÂèñÂæóÔºà„Ç≠„É£„ÉÉ„Ç∑„É•‰ªò„ÅçÔºâ
   */
  async getPhotoChunk(photoId: bigint, chunkIndex: bigint, identity?: Identity): Promise<Uint8Array | null> {
    // „Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    const cacheKey = `chunk_${photoId}_${chunkIndex}`;
    const cached = this.chunkCache.get(cacheKey);
    if (cached) {
      console.log('üöÄ Photo chunk cache hit:', photoId, chunkIndex);
      return cached;
    }

    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      debugLog('API_CALLS', 'üì• Fetching photo chunk:', photoId, chunkIndex);
      const startTime = Date.now();
      
      const result = await this.actor.getPhotoChunkV2(photoId, chunkIndex);
      
      const fetchTime = Date.now() - startTime;
      debugLog('API_CALLS', `üìä Photo chunk fetch time: ${fetchTime}ms`);
      
      if (result.length > 0) {
        const chunk = new Uint8Array(result[0]);
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠òÔºà„ÉÅ„É£„É≥„ÇØ„ÅØÂ§ß„Åç„ÅÑ„ÅÆ„ÅßÁü≠„ÇÅ„ÅÆ„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÔºâ
        this.chunkCache.set(cacheKey, chunk);
        setTimeout(() => this.chunkCache.delete(cacheKey), this.cacheTimeout / 2);
        
        return chunk;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Get photo chunk error:', error);
      return null;
    }
  }

  /**
   * ÂÜôÁúüÁµ±Ë®àÊÉÖÂ†±„ÇíÂèñÂæó
   */
  async getPhotoStats(identity?: Identity): Promise<OverallPhotoStatsV2 | null> {
    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      const result = await this.actor.getPhotoStatsV2();
      return result;
    } catch (error) {
      console.error('‚ùå Get photo stats error:', error);
      return null;
    }
  }

  /**
   * „É¶„Éº„Ç∂„Éº„ÅÆÂÜôÁúü„ÇíÂèñÂæó
   */
  async getUserPhotos(cursor?: bigint, limit: number = 20, identity?: Identity): Promise<SearchResult> {
    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      // Dev mode„Åã„Å©„ÅÜ„ÅãÁ¢∫Ë™ç
      const isDevMode = this.identity && this.identity.constructor.name === 'Ed25519KeyIdentity';
      
      if (isDevMode) {
        console.log('üñºÔ∏è Calling getUserPhotosV2 in dev mode with principal:', this.identity?.getPrincipal().toString());
      }
      
      const result = await this.actor.getUserPhotosV2(cursor ? [cursor] : [], BigInt(limit));
      
      if (isDevMode) {
        console.log('üñºÔ∏è getUserPhotosV2 result in dev mode:', {
          photoCount: result.photos.length,
          hasMore: result.hasMore
        });
      }
      
      return result;
    } catch (error) {
      console.error('‚ùå Get user photos error:', error);
      return {
        photos: [],
        totalCount: BigInt(0),
        cursor: null,
        hasMore: false,
      };
    }
  }

  /**
   * ÂÜôÁúü„ÇíÂâäÈô§
   */
  async deletePhoto(photoId: bigint, identity?: Identity): Promise<{ ok?: null; err?: string }> {
    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      const result = await this.actor.deletePhotoV2(photoId);
      return result;
    } catch (error) {
      console.error('‚ùå Delete photo error:', error);
      return { err: error instanceof Error ? error.message : 'Delete failed' };
    }
  }

  /**
   * ÂÜôÁúü„ÅÆË©≥Á¥∞Áµ±Ë®àÊÉÖÂ†±„ÇíÂèñÂæó
   */
  async getPhotoStatsDetails(photoId: bigint, identity?: Identity): Promise<PhotoStatsDetailsV2 | null> {
    // „Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    const cacheKey = `stats_${photoId}`;
    const cached = this.statsCache.get(cacheKey);
    if (cached) {
      return cached;
    }

    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      debugLog('API_CALLS', 'üìä Fetching photo stats details:', photoId);
      const result = await this.actor.getPhotoStatsDetailsV2(photoId);
      if (result.length > 0) {
        const stats = result[0];
        this.statsCache.set(cacheKey, stats);
        setTimeout(() => this.statsCache.delete(cacheKey), this.cacheTimeout);
        return stats;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Get photo stats details error:', error);
      return null;
    }
  }

  /**
   * ÂÜôÁúü„ÅÆÂÆåÂÖ®„Å™„Éá„Éº„Çø„ÇíÂèñÂæóÔºàÂÖ®„ÉÅ„É£„É≥„ÇØÁµêÂêàÊ∏à„ÅøÔºâ
   * Uses the backend getPhotoCompleteDataV2 method directly
   */
  async getPhotoCompleteData(photoId: bigint, identity?: Identity): Promise<Uint8Array | null> {
    // „Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    const cacheKey = `complete_${photoId}`;
    const cached = this.chunkCache.get(cacheKey);
    if (cached) {
      debugLog('API_CALLS', 'üöÄ Complete photo data cache hit:', photoId);
      return cached;
    }

    if (!this.actor && identity) {
      await this.init(identity);
    }

    try {
      debugLog('API_CALLS', 'üì• Fetching complete photo data:', photoId);
      const startTime = Date.now();
      
      // Use the backend method directly
      const result = await this.actor.getPhotoCompleteDataV2(photoId);
      
      const fetchTime = Date.now() - startTime;
      
      if (result.length > 0) {
        const completeData = new Uint8Array(result[0]);
        debugLog('API_CALLS', `üìä Complete photo data fetch time: ${fetchTime}ms, size: ${completeData.length} bytes`);
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠ò
        this.chunkCache.set(cacheKey, completeData);
        setTimeout(() => this.chunkCache.delete(cacheKey), this.cacheTimeout);
        
        return completeData;
      }
      
      console.log('‚ùå No photo data found for ID:', photoId);
      return null;
    } catch (error) {
      console.error('‚ùå Get complete photo data error:', error);
      return null;
    }
  }

  /**
   * ÂÜôÁúü„Éá„Éº„ÇøURLÔºàbase64Ôºâ„ÇíÂèñÂæóÔºàÈ´òÈÄüÂ§âÊèõÔºã„Ç≠„É£„ÉÉ„Ç∑„É•‰ªò„ÅçÔºâ
   */
  async getPhotoDataUrl(photoId: bigint, identity?: Identity): Promise<string | null> {
    const cacheKey = `dataurl_${photoId}`;
    const cached = this.dataUrlCache.get(cacheKey);
    if (cached) {
      return cached;
    }

    const completeData = await this.getPhotoCompleteData(photoId, identity);
    if (!completeData) return null;

    // Âà§ÂÆöÔºö„Åô„Åß„Å´„ÉÜ„Ç≠„Çπ„ÉàÔºàdataURL„ÇÑBase64ÊñáÂ≠óÂàóÔºâ„ÅåËøî„Å£„Å¶„Åç„Å¶„ÅÑ„Çã„Åã
    const decoder = new TextDecoder();
    const head = completeData.slice(0, Math.min(100, completeData.length));
    const headText = decoder.decode(head);

    let dataUrl: string;
    if (headText.includes('data:image')) {
      // dataURL„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Å®„Åó„Å¶Ëøî„Å£„Å¶„Åç„Å¶„ÅÑ„Çã
      const asText = decoder.decode(completeData);
      dataUrl = asText;
    } else if (/^[A-Za-z0-9+/]/.test(headText)) {
      // Base64„ÉÜ„Ç≠„Çπ„Éà„Å®„Åó„Å¶Ëøî„Å£„Å¶„Åç„Å¶„ÅÑ„Çã
      const base64String = decoder.decode(completeData);
      dataUrl = base64String.startsWith('data:')
        ? base64String
        : `data:image/jpeg;base64,${base64String}`;
    } else {
      // „Éê„Ç§„Éä„É™ -> Base64 È´òÈÄüÂ§âÊèõ
      const base64 = uint8ToBase64(completeData);
      dataUrl = `data:image/jpeg;base64,${base64}`;
    }

    this.dataUrlCache.set(cacheKey, dataUrl);
    setTimeout(() => this.dataUrlCache.delete(cacheKey), this.cacheTimeout);
    return dataUrl;
  }


  /**
   * 3ÊÆµÈöé„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Éò„É´„Éë„Éº
   */
  async uploadPhotoWithChunks(
    data: {
      imageData: string; // Base64
      metadata: CreatePhotoRequest;
    },
    identity?: Identity,
    onProgress?: (progress: number) => void
  ): Promise<{ ok?: bigint; err?: string }> {
    try {
      // 1. ÂÜôÁúü„Çí‰ΩúÊàê
      const createResult = await this.createPhoto(data.metadata, identity);
      if (createResult.err) {
        return createResult;
      }
      
      const photoId = createResult.ok!;
      console.log(`üñºÔ∏è Created photo with ID: ${photoId}`);
      
      // 2. „ÉÅ„É£„É≥„ÇØ„Å´ÂàÜÂâ≤„Åó„Å¶„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
      const CHUNK_SIZE = 256 * 1024; // 256KB
      const base64Data = data.imageData;
      const totalChunks = Math.ceil(base64Data.length / CHUNK_SIZE);
      
      for (let i = 0; i < totalChunks; i++) {
        const chunkData = base64Data.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
        const chunkBytes = new TextEncoder().encode(chunkData);
        
        const uploadResult = await this.uploadChunk(photoId, BigInt(i), chunkBytes, identity);
        if (uploadResult.err) {
          return { err: `Chunk ${i} upload failed: ${uploadResult.err}` };
        }
        
        if (onProgress) {
          onProgress((i + 1) / totalChunks);
        }
      }
      
      // 3. „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÇíÂÆå‰∫Ü
      const finalizeResult = await this.finalizeUpload(photoId, identity);
      if (finalizeResult.err) {
        return { err: `Finalize failed: ${finalizeResult.err}` };
      }
      
      console.log(`üñºÔ∏è Successfully uploaded photo ${photoId}`);
      return { ok: photoId };
      
    } catch (error) {
      console.error('‚ùå Upload photo with chunks error:', error);
      return { err: error instanceof Error ? error.message : 'Upload failed' };
    }
  }
}

export const photoServiceV2 = new PhotoServiceV2();

// „Éò„É´„Éë„ÉºÈñ¢Êï∞
export function sceneKindFromString(scene: string): SceneKind {
  switch (scene.toLowerCase()) {
    case 'nature': return { Nature: null };
    case 'building': return { Building: null };
    case 'store': return { Store: null };
    case 'facility': return { Facility: null };
    default: return { Other: null };
  }
}

export function sceneKindToString(kind: SceneKind): string {
  if ('Nature' in kind) return 'nature';
  if ('Building' in kind) return 'building';
  if ('Store' in kind) return 'store';
  if ('Facility' in kind) return 'facility';
  return 'other';
}

export function difficultyFromString(diff: string): { EASY: null } | { NORMAL: null } | { HARD: null } | { EXTREME: null } {
  switch (diff.toUpperCase()) {
    case 'EASY': return { EASY: null };
    case 'NORMAL': return { NORMAL: null };
    case 'HARD': return { HARD: null };
    case 'EXTREME': return { EXTREME: null };
    default: return { NORMAL: null };
  }
}

// È´òÈÄü„Å™ Uint8Array -> Base64 Â§âÊèõÔºàÂ§ß„Åç„Å™ÈÖçÂàó„Å´ÂØæÂøúÔºâ
function uint8ToBase64(bytes: Uint8Array): string {
  let binary = '';
  const chunkSize = 0x8000; // 32KB „ÉÅ„É£„É≥„ÇØ
  for (let i = 0; i < bytes.length; i += chunkSize) {
    const sub = bytes.subarray(i, i + chunkSize);
    // Hermes „Åß„ÅØ apply „Å´ TypedArray „ÅØÁõ¥Êé•Ê∏°„Åõ„Å™„ÅÑÂ†¥Âêà„Åå„ÅÇ„Çã„Åü„ÇÅ Array „Å´Â§âÊèõ
    binary += String.fromCharCode.apply(null, Array.from(sub) as unknown as number[]);
  }
  return btoa(binary);
}

// ÁîªÂÉèURI„ÇíBase64„Å´Â§âÊèõ„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
export async function imageUriToBase64(uri: string): Promise<string> {
  const response = await fetch(uri);
  const blob = await response.blob();
  
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const base64String = reader.result as string;
      // data:image/jpeg;base64, „ÇíÈô§Âéª
      resolve(base64String.split(',')[1]);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// ÁîªÂÉèURI„ÇíBlob„Å´Â§âÊèõ„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
export async function imageUriToBlob(uri: string): Promise<Blob> {
  const response = await fetch(uri);
  return response.blob();
}

// Blob„ÇíUint8Array„Å´Â§âÊèõ„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞ÔºàReact NativeÂØæÂøúÔºâ
export async function blobToUint8Array(blob: Blob): Promise<Uint8Array> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      if (reader.result instanceof ArrayBuffer) {
        resolve(new Uint8Array(reader.result));
      } else {
        reject(new Error('Failed to convert blob to ArrayBuffer'));
      }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(blob);
  });
}



// Âú∞ÂüüÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞ÔºàÁ∞°Á¥†ÂåñÁâàÔºâ
export async function getRegionInfo(latitude: number, longitude: number): Promise<{ country: string; region: string }> {
  try {
    console.log('üåç Getting region info for coordinates:', { latitude, longitude });
    
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=10&addressdetails=1&accept-language=en`;
    console.log('üåç Region info URL:', url);
    
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'SpotQuestApp/2.0 (https://spotquest.app; contact@spotquest.app)',
        'Accept': 'application/json',
        'Accept-Language': 'en',
      },
    });
    
    console.log('üåç Region info response status:', response.status);
    
    if (!response.ok) {
      console.error('üåç Region info request failed with status:', response.status);
      const text = await response.text();
      console.error('üåç Response text:', text.substring(0, 200));
      throw new Error(`Geocoding request failed with status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('üåç Region info response data:', JSON.stringify(data, null, 2));
    const address = data.address || {};
    
    // Êñ∞„Åó„ÅÑÁ∞°Á¥†Âåñ„Åï„Çå„Åü„Ç¢„Éó„É≠„Éº„ÉÅ: Ëã±Ë™ûÂú∞ÂüüÂêç„Çí„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®
    const { formatLocationName, normalizeCountryName } = await import('../utils/regionMapping');
    
    const locationName = formatLocationName(address);
    
    // ÂõΩÂêç„ÇíÊ≠£Ë¶èÂåñ
    const countryName = normalizeCountryName(address.country || 'Unknown');
    
    console.log('üåç Simplified geocoding result:', {
      locationName,
      countryName,
      fullAddress: data.display_name,
    });
    
    return { 
      country: countryName, 
      region: locationName 
    };
    
  } catch (error) {
    console.error('‚ùå Geocoding error:', error);
    
    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Â∫ßÊ®ô„Åã„ÇâÂ§ß„Åæ„Åã„Å™Âú∞Âüü„ÇíÊé®ÂÆö
    let fallbackCountry = 'Unknown';
    let fallbackRegion = 'Unknown Location';
    
    // ÂåóÁ±≥„ÅÆÂ§ß„Åæ„Åã„Å™ÁØÑÂõ≤
    if (latitude >= 25 && latitude <= 70 && longitude >= -170 && longitude <= -50) {
      if (latitude >= 49) {
        fallbackCountry = 'Canada';
      } else if (latitude >= 30) {
        fallbackCountry = 'United States';
      } else {
        fallbackCountry = 'Mexico';
      }
      
      // „Ç¢„É°„É™„Ç´„ÅÆ‰∏ªË¶ÅÈÉΩÂ∏Ç„ÅÆÁØÑÂõ≤
      if (fallbackCountry === 'United States') {
        if (latitude >= 37 && latitude <= 38 && longitude >= -123 && longitude <= -122) {
          fallbackRegion = 'San Francisco, United States';
        } else if (latitude >= 40.5 && latitude <= 41 && longitude >= -74.5 && longitude <= -73.5) {
          fallbackRegion = 'New York, United States';
        } else if (latitude >= 33.5 && latitude <= 34.5 && longitude >= -118.5 && longitude <= -117.5) {
          fallbackRegion = 'Los Angeles, United States';
        } else {
          fallbackRegion = `${fallbackCountry} (${latitude.toFixed(2)}¬∞, ${longitude.toFixed(2)}¬∞)`;
        }
      }
    }
    // Êó•Êú¨„ÅÆÂ§ß„Åæ„Åã„Å™ÁØÑÂõ≤
    else if (latitude >= 30 && latitude <= 46 && longitude >= 129 && longitude <= 146) {
      fallbackCountry = 'Japan';
      if (latitude >= 35.5 && latitude <= 36 && longitude >= 139.5 && longitude <= 140) {
        fallbackRegion = 'Tokyo, Japan';
      } else if (latitude >= 34.5 && latitude <= 35 && longitude >= 135 && longitude <= 136) {
        fallbackRegion = 'Osaka, Japan';
      } else {
        fallbackRegion = `Japan (${latitude.toFixed(2)}¬∞, ${longitude.toFixed(2)}¬∞)`;
      }
    }
    
    console.log('üìç Using fallback location:', { country: fallbackCountry, region: fallbackRegion });
    return { country: fallbackCountry, region: fallbackRegion };
  }
}

export default photoServiceV2;
